\documentclass[a4paper,oneside,11pt]{report}

%------------ package pour langue fr ------
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{multirow}
%------------- for embedding images----------
\usepackage{graphicx} 
\usepackage{float}
\usepackage[export]{adjustbox}
\usepackage{amsfonts,epsfig,epstopdf,titling,url,array}
\usepackage{lscape}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%--------- pour le style de la page ----------
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}

\usepackage[]{geometry}

\usepackage{algorithm}
\usepackage{algorithmic}


\usepackage{setspace}
\setstretch{1,15}
%\usepackage{txfonts} //pour utiliser times new roman dans le document
\usepackage{fancyhdr}
\fancyhf{} % clear all header and footers
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\fancyfoot[RE,RO]{\thepage} % Left side on Even pages; Right side on Odd pages
\pagestyle{fancy}
\fancypagestyle{plain}{%
  \fancyhf{}%
  \renewcommand{\headrulewidth}{0pt}%
  \fancyhf[lef,rof]{\thepage}%
}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{\textbf{Chapitre \thechapter}}
\fancyhead[R]{\rightmark}

%--------------------------- Sommaire ----------------------------%
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{natbib}
\theoremstyle{definition}
		\newtheorem{defn}{Definition}[section]
		\newtheorem{conj}{Conjecture}[section]
		\newtheorem{exmp}{Example}[section]
\usepackage[table,dvipsnames]{xcolor}	

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\xmark}{\color{red}\ding{55}}%
\newcommand{\cmark}{\color{PineGreen}\ding{51}}	
\usepackage[T1]{fontenc}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash }b{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash }b{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash }b{#1}}

\usepackage[most]{tcolorbox}

\tcbset{
    frame code={}
    center title,
    left=0pt,
    right=0pt,
    top=0pt,
    bottom=0pt,
    colback=gray!70,
    colframe=white,
    width=\dimexpr\textwidth\relax,
    enlarge left by=0mm,
    boxsep=5pt,
    arc=0pt,outer arc=0pt,
    }

\begin{document}

%Page de garde (page de titre)							Obligatoire
\pagenumbering{Roman}
\input{./title.tex}

%Remerciements											Obligatoire
\input{./Remerciement.tex}

%Résumé												Obligatoire
\input{./abstract.tex}

%Sommaire (Table des matières)							Obligatoire
\tableofcontents
\newpage

%Liste des figures										Selon besoin
\listoffigures
\addcontentsline{toc}{chapter}{\numberline{}Liste des figures}
\cleardoublepage

%Liste des tableaux										Selon besoin

\listoftables
\addcontentsline{toc}{chapter}{\numberline{}Liste des tableaux}
\cleardoublepage

%Introduction (début de la pagination)					bligatoire

\pagenumbering{arabic}


		\Huge{ 
			\textbf {Introduction générale}} \\[0.5in]
			\addcontentsline{toc}{chapter}{\numberline{}Introduction générale}
			\normalsize
			Avec l'énorme quantité de données produites par les activités humaines de nos jours, le problème de données massives (Big data) est devenu un enjeu essentiel. Un des outils efficaces pour traiter ces données est l'utilisation de graphes. Les graphes sont des outils de modélisation utilisés dans beaucoup de domaines pour la représentation des données : réseaux sociaux et de communication (entités reliées entre elles par des liens physiques ou communautaires), chimie (relations entre les atomes), biologie (interactions entre protéines par exemple), etc.\\
			
Il y a plusieurs solutions pour contrer le volume de données mais nous nous intéressons à une solution aussi vieille que la discipline de traitement de données mais qui connait de nouveaux défis de nos jours : la compression.\\

La compression de graphes est un domaine dans lequel le graphe initial subit des transformations pour en obtenir une version plus réduite. Différentes techniques permettent cette compression, avec ou sans perte d'information, et génèrent de nouveaux graphes sur lesquels il est intéressant d'effectuer les différents traitement.\\ 

Deux types de méthodes de compression des graphes se sont distinguées parmi toute les autres types de méthodes: les k2-trees et les méthodes de compression par extraction de motifs. En effet, elles permettent de trouver dans la majorité des cas un bon compromis entre l'espace mémoire et les temps de traitements. Nous présenterons dans ce travail une synthèse bibliographique sur les différentes méthodes de compression dérivant de ces deux grandes classes.	\\
		
			
			 Nous avons hiérarchisé notre mémoire en trois grands chapitres. Le premier est une introduction au domaine de la théorie des graphes incluant ainsi les notion fondamentales de ce domaine, les types de graphes, leurs représentations structurelles et leurs domaines d'application. Dans le second chapitre, nous introduisons les définitions de base du domaine de compression de données appliqué aux graphes à savoir: les motivation, les types de compression et les métriques d'évaluation. Enfin, nous présenterons les classification des méthodes de compression des graphes existantes ainsi que la classification que nous proposons. Nous mettrons l'accent après sur les deux classes de méthode qui forment la problématique de notre sujet de Master: la compression par extraction de motifs et la compression par les k2-trees. Dans le troisième chapitre nous présenterons une nouvelle méthode de compression que nous proposons.
	



%---->chapitre 01 :« cadrage du projet »
	\chapter{ Théorie des graphes}
	  \input{./Chapitres/TheorieDesGraphes/TheorieDesGraphes.tex}
	

%---->chapitre 02 :« »
	\chapter{Compression de graphe}
	
		\section{Compression de données: }
			\input{./Chapitres/CompressionDesGraphes/datacompression.tex}
			
		
		\section{Compression appliquée aux graphes:}
	
			\subsection{Motivations derrière la compression de graphes: }
	
			\subsection{Les types de compression:}
			\input{./Chapitres/CompressionDesGraphes/TypeDeCompression.tex}
			
	
			\subsection{Les métriques d'évaluation des algorithmes de compression:}
				\input{./Chapitres/CompressionDesGraphes/MOE.tex}
			
			\subsection{Classification des méthodes de compression:}
				\input{./Chapitres/CompressionDesGraphes/classification.tex}
			\section{Compression par les K2-Trees}
				\input{./Chapitres/k2_trees/K2-trees.tex}
				\input{./Chapitres/k2_trees/SynK2.tex}
			\section{Compression par extraction de motifs}
			 Les motifs fréquents sont des connaissances extraites sur des données. Leur but est de fournir à l'utilisateur des informations non triviales, implicites, présumées non connues. Ils offrent ainsi à l'utilisateur une meilleure appréhension des données. L'extraction de motifs fréquents est ainsi devenue une tâche importante de la fouille de données et un thème très étudié par la communauté. Elle a aussi été vastement%%%% verifier ce mot
			 utilisée dans le domaine de compression des graphes vue qu'elle permet de ne garder que l'information utiles et d'éliminer les redondances de manière efficace. En effet, nous trouvons plusieurs méthodes basées sur ce principe dont nous proposons de les classifier en deux grandes classes: 
			 (i) les méthodes  de compression basées vocabulaire
			 (ii) les méthodes  de compression basées Agrégation.
			 
				Dans cette section, nous allons expliquer le principe de base de chaque classe où nous allons subdiviser chacune  en plusieurs sous-classe en se basant sur ce dernier. 
				%%% a revoir le dernier paragraphe
			 
				\subsection{Compression basée vocabulaire}
				Les méthodes de compression par extraction de motifs basées vocabulaire sont des méthodes qui ont attirées l'attention des chercheurs ces dernières années car elles permettent une meilleurs compréhension du graphe. Elles partent toujours d'un ensemble de structures prédéfinies qui ont été prouvées fréquent dans les graphes réels. Deux sous classes de cette dernières peuvent être d:
				 
					 \textbf{Basées sur des méthodes de clustering}
							
							Les méthodes de cette classe s'appuient sur le fait qu'on ne peut pas comprendre facilement les graphes denses, alors que quelques structures simples sont beaucoup plus faciles à comprendre et souvent très utiles pour analyser le graphe. Elles se basent sur des algorithmes de détection de communautés. 
							La question suivante peut alors se poser: pourquoi ne pas appliquer l'un des nombreux algorithmes de détection de communauté ou de partitionnement de graphe pour compresser le graphe en termes de communautés? La réponse est que ces algorithmes ne servent pas tout à fait le même objectif que la compression. Généralement, ils détectent de nombreuses communautés sans ordre explicite, de sorte qu'une procédure de sélection des sous-graphes les plus «importants» est toujours nécessaire. En plus de cela, ces méthodes renvoient simplement les communautés découvertes, sans les caractériser (par exemple, clique, étoile) et ne permettent donc pas à l'utilisateur de mieux comprendre les propriétés du graphe. 
							
							\input{./Chapitres/ExtractionMotifs/EM.tex}
							\input{./Chapitres/ExtractionMotifs/VOG.tex}
							\input{./Chapitres/ExtractionMotifs/VOG_Overlapp.tex}
							\input{./Chapitres/ExtractionMotifs/TimeCrunch.tex}
							\input{./Chapitres/ExtractionMotifs/CanDense.tex}
							%\input{./Chapitres/ExtractionMotifs/SynNoeudClust.tex}
			
					 \textbf{Basée sur les propriétés de la matrice d'adjacence}
							
							Les graphes peuvent avoir différentes représentations. Chacune des structures de données présente des avantages et des inconvénients en ce qui concerne la quantité de mémoire nécessaire pour stocker les données et la facilité d'accès aux données. Selon les besoins, il est parfois utile de stocker les données dans des structures de données plus grandes, qui nécessitent plus d'espace mais offrent un accès efficace aux données. En se basant sur ce constat plusieurs méthodes ont été  proposée dans la littérature pour compresser la matrice d'adjacence en exploitant les propriété des graphes réels pour trouver les motifs les plus fréquent dans cette dernière.
							
							\input{./Chapitres/ExtractionMotifs/intra_inter_mot_mat.tex}
							\input{./Chapitres/ExtractionMotifs/mot_mat.tex}
						%	\input{./Chapitres/ExtractionMotifs/SynMatMot.tex}
					
				
				%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				\subsection{Compression basée Agrégation des motifs}
				
					Les méthodes de compression par extraction de motifs basées sur l'agrégation sont des méthodes   qui agrègent plusieurs nœuds ou liens d'un motif en un seul nœud ou lien, appelés respectivement super-nœud et super-lien. Le graphe en sortie, dit super-graphe, devient dès lors plus simple et moins offrant ainsi une aisance et une facilité de traitement, d'exploration et de visualisation. 
					
					Nous présenterons dans ce qui suit les deux sous-classes de cette classe. 
					
					 
					\subsubsection{Compression basée Agrégation de nœuds}
					
					Les techniques de compression basées sur l'agrégation des nœuds des motifs sont des méthodes qui ont existé depuis plusieurs décennies offrant plusieurs avantages. 
					Elles visent à résumer le graphe initial en agrégeant les nœuds des motifs découvert dans le but de diminuer le nombre de nœuds existants  et d'offrir une meilleur visibilité et analyse du graphe. 
						
						\input{./Chapitres/ExtractionMotifs/SubDue.tex}
						\input{./Chapitres/ExtractionMotifs/GraphZip.tex}
					%	\input{./Chapitres/ExtractionMotifs/SynAgrNoeud.tex}
						
					\subsubsection{Compression basée agrégation de liens}
						Les méthodes de compression par extraction de motifs basées agrégation de liens sont parmi les méthode les plus populaires. Leur objectif est de produire un graphe compressé à partir du graphe initial en remplaçant les liens denses du graphe par un nouveau super-nœud ou une nouvelle super-arêtes. Elle se divise selon le principe en deux grandes classes: celles utilisant les règles de grammaire et celles utilisant des méthode de clustering. Nous détaillerons dans ce qui suit ces deux classes et nous conclurons par une synthèse sur les méthodes de chaque classe.
						
						 \textbf{Basées sur les règles de grammaire} 
								
								La classe des méthodes de compression basées sur les règles de grammaire est une généralisation d'une méthode de compression des dictionnaire s'intitulant Re-pair. Son principe de base consiste en la  recherche, à chaque itération, de la paire de symboles la plus fréquente dans une séquence de caractères et à la remplacer par un nouveau symbole, jusqu'à ce qu'il ne soit plus commode de les remplacer. Nous notons que dans ce cas le motif est sous forme de deux arêtes ayant un sommet en commun, nommé \textit{digraph}.
								
								\input{./Chapitres/ExtractionMotifs/appRep.tex}
								 %%%%exemple ???
								\input{./Chapitres/ExtractionMotifs/appRepAmel.tex}
								\input{./Chapitres/ExtractionMotifs/k2-partitionned.tex}
							
								\input{./Chapitres/ExtractionMotifs/gRepair.tex}
								%%%%exemple ???
							%	\input{./Chapitres/ExtractionMotifs/SynGram.tex}
								

								
%%% Ajouter son algorithme
%%%% Ajouter un exmple illustant cette methode
								
						 \textbf{Basées sur des méthodes de clustering}
						 
						 		Les méthodes de compression appartenant à la classe courante sont des méthodes basées sur la recherche des sous-graphes denses (ayant des nœuds fortement connectés). Ils sont destinées principalement aux graphes du Web et les graphes des réseaux sociaux dans but de faciliter leurs exploration et analyse.
								
								\input{./Chapitres/ExtractionMotifs/VNM.tex}
								\input{./Chapitres/ExtractionMotifs/DSM.tex}
							%	\input{./Chapitres/ExtractionMotifs/SynAgrlien.tex}
						
						\input{./Chapitres/ExtractionMotifs/SynGen.tex}						
								
		\section{Synthèse Générale}
	


	\chapter{Contribution}
		Comme on vient de voir dans les chapitres précédents, de nombreux phénomènes dans des contextes très variés peuvent être représenter par des graphes. Citons en particuliers les réseaux sociaux qui nous attirent vue leurs évolutions. Aujourd'hui 3.0 milliards de personnes utilisent les réseaux sociaux, voir 40\% de la population sur terre. Ces grandes tailles des données manipulées rendent impossible tout traitement et demandent un grand espace de stockage faisant intervenir des algorithmes de compression adéquats qui changent selon le type de graphes. Les graphes statiques ne sont pas toujours suffisants pour décrire les situations de la vie réel et leurs évolutions dans le temps. Ajouter une dimension temporelle a ces graphes permet d'élargir l'espace de possibilités, les réseaux sociaux en ligne est un exemple qui nous captive où le suivi dynamique du graphe est nécessaire. Quoiqu'il existe de nombreuses techniques efficaces adaptés au contexte statiques, rares sont ceux qui proposent une contrepartie dynamique, ce qui nous amène à nous intéresser particulièrement à ce type de graphes toujours en cours d'évolutions. Nous nous sommes intéressés aussi dans ce travail à un autre enjeu important qui provient de la structures complexe de ces graphes qui pose un problème lors de l'exploration du graphe ce qui rend difficile l'analyser des données et l'extraction des informations pertinentes. La recherche de motifs et particulièrement les clique et les noyaux bipartie qui sont fréquents dans les réseaux sociaux répond à ce problème.\\
Pour résumé, Nous allons dans cette partie proposé une nouvelle méthode DDSM basé sur deux approches existantes que nous avons étudier dans notre état de l'art. Notre but principal est de développer une technique de compression compétitives pour les graphes des réseaux sociaux dans un contexte dynamique en se basant sur l'extraction de motifs. Pour accomplir ce travail nous nous somme appuyer sur ces deux méthodes :
\begin{itemize}
\item Exploiter la structure de donnés compressés proposé dans DSM \citep{hernandez2014compressed} qui permet de représenter les sous-graphes denses comme les cliques, les bi-cliques, noyaux bipartis. Nous avons optés pour cette structure car on l'appliquant sur les réseaux sociaux, elle donne de bons résultats en termes d'espace et de temps de requêtes.  
\item Adopter les signatures temporelles utilisés dans TimeCrunch \citep{shah2015timecrunch} pour décrire le comportement des sous-graphes dans le temps. Nous avons utilisé ces signatures car elle englobent tous les types des sous graphes temporelles qu'on peut trouver dans un graphe dynamique et c'est les seules qu'on a rencontrer dans ce genre.
\end{itemize}	
Nous allons dans cette partie présenter notre méthode théoriquement : principe générale, structures utilisés et un pseudo code.	
		
		\section{Formulation du problème}
		Dans cette section, nous allons définir le problème de base auquel notre méthode convient tout en définissant le cadre dans lequel elle peut être appliquée. 
		
		Nous considèrent les graphes orientés dynamiques $\displaystyle{G=\bigcup_{t_{i}}G_{t_{i}}(V,E_{t_{i}})}\ \ 1 \preceq i \preceq t$ où $G_{t_{i}}$ = G a l'instant $t_{i}$ et un ensemble de signature temporelle. En d'autre termes, nous considérons des captures du graphe à des instants différents $t_{i}$ et un ensemble de descripteurs de comportement temporels des sous graphes des différents $G_{t_{i}}$. Le problème peut ainsi être formulé:
		
			\textit{\textbf{Problème:}
		Trouver, à partir d'un graphe dynamique G et un lexique de signatures temporelles, la plus petite description du graphe initiale en terme de ces structures les plus denses et leur comportement temporel, en offrant la possibilité d'extraire les voisins directes et d'extraire les sous-graphes au besoin. }

		\section{Principe générale}
			Notre méthode s'intitule DDSM pour \textit{Dynamic Dense Substructure Mining}. Elle représente une généralisation du travail de Hernandez et Navarro\citep{hernandez2014compressed} pour le cas des graphes dynamiques qui sont de nos jours omniprésents dans différents domaines.
			
			Pour mieux expliquer notre méthode nous allons tout d'abords commencer par décrire les structures que nous allons utiliser. Nous enchainons par la suite  avec le pseudo algorithme détaillant les étapes essentielles de notre méthode et nous conclurons en expliquant comment les algorithmes proposés dans \citep{hernandez2014compressed} de manipulation des graphes peuvent être généraliser dans notre cas.
			\subsection{Description conceptuelle}
			
			La codification du graphe en sortie doit respecter les contraintes du problème tout en réduisant un maximum d'espace mémoire. Nous proposons pour cela d'augmenter la codification proposées dans \citep{hernandez2014compressed} dans le cas des graphes dynamiques en rajoutant une l'information temporelle. 
			
			Une fois les sous-structures identifiées, hernandez et al. \citep{hernandez2014compressed} proposent de représenter chacune d'elles avec trois composantes: la première contenant les sommet ayant uniquement des aretes sortantes, la deuxième contenant les sommet ayant des arêtes entrantes et sortantes et la troisième contenant les sommet ayant uniquement des arêtes entrantes. Pour pouvoir identifier les différentes composantes, ils associent un vecteur binaire à cette représentation marquant par un 1 le début de chacune des trois composantes (voir figure \ref{SDM}).
			
			Notre première contribution consiste en l'extension de cette structure. En effet, nous suggérons de representer chaque structure avec non trois composantes mais quartes. Les trois premières étant les même que dans \citep{hernandez2014compressed}, la quatrième représente l'information temporelle. Cette dernière peut être sous cinq formats (voir \ref{par:TimeCrunch}) dont nous résumons la représentation proposée pour chacune dans le tableau \ref{tab:signtmp}.
			
			\begin{table}[h]
			\label{tab:signtmp}
			\begin{center}
			\begin{tabular}{|r|l|}
			\hline Signature temporelle & Représentation	
			\\\hline constante & 0	
			
			\\\hline OneShot & 1 $t_{1}$	
			
			\\\hline ranged & 2	$t_{1}\ t_{2}$	
			
			\\\hline periodic & 3  $T$	
			
			\\\hline flikering & 4 $t_{1}\ t_{2}\ ...\ t_{n}$	
			
			\\\hline			
			\end{tabular}
			\end{center}
			
			 \caption{\small {Les types de signatures temporelles et leurs représentations, $t_{i}$	 représentent les timestamps et T représente la période.}}
			\end{table}
			
			Nous représentons G donc en tant qu'un ensemble de sous-graphes temporels denses. Cependant, pour obtenir une compression sans perte, nous devons aussi garder information sur l'erreur modélisant l'ensemble d'arêtes restantes dans chaque $G_{t_{i}}$. Nous proposons pour cela d'utiliser une des structures dynamiques des k2-trees qui nous permettra d'interroger le graphe de manière simple et efficace.
			
			\subsection{Notre méthode : DDSM}
			 Nous visons à travers la méthode que nous proposons d'exprimer le graphe en entrée avec ses sous-structures les plus dense et leurs comportement temporels réduisant ainsi sa taille et offrant la possibilité d'effectuer les traitements dans un temps meilleur. Nous avons structurer notre algorithme sous forme de trois (03) étapes essentielles, chacune servant d'entrée pour l'étape suivante.
			 
			 En premier lieu, nous appliquons la découverte des sous-graphes les plus denses. Pour effectuer cela de manière efficace, nous suggérons d'utiliser l'approche proposée dans \citep{hernandez2014compressed} parallèlement sur chaque capture $G_{t_{i}}$ de G. Nous allons donc considérer les listes d'adjacences pour chaque $G_{t_{i}}$ où des fonctions de hachages sont calculées pour chaque sommet. Une arborescence est ensuite construite pour chaque ensemble de sommets ayant les même valeurs de hachages et qui permettra d'extraire les structures denses du graphe à travers un parcours de la racine vers les feuilles. 
			 
			 Dans une deuxième phase, nous effectuons une comparaison entre les structures découvertes dans des timestamps différents. Nous proposons pour décrire le comportement de ces derniers d'utiliser le même ensemble de signatures temporelles proposées dans \citep{shah2015timecrunch} composées de six descripteurs temporelles englobant tout les cas possibles. Durant cette étape, nous tolérons un certains seuil d'erreur qui sera inclus dans la représentation de l'erreur.
			 
			 Une dernière phase consiste en la codification du graphe en utilisant le codage proposés dans la section précédentes pour chaque structure de a phase (02). Nous concaténons par la suite ces représentations pour obtenir une seule représentation concise du graphe initiale en terme de ses structures les plus denses. 
			L'algorithme ci-dessous résume les trois principales étapes de notre méthode :
			\begin{algorithm}
					\label{alg:DDSM}
					\caption{DDSM}
					\label{Pseudo Algorithme de la méthode proposée (DDSM)}
				\begin{algorithmic} [1]
					\STATE \textbf{Génération des sous-structures candidates: }Génération de sous-graphes, principalement les sous-graphes bipartis et les cliques.
					
					\STATE  \textbf{Étiquetage de sous-structures: }Associer chaque sous-structure à une signature temporelle décrivant son comportement.
					
					\STATE \textbf{Codification du graphe compressé: }Codifier les sous-structures étiquetées de l'étape 02 en utilisant les structures de la section précédente.
				\end{algorithmic}
			\end{algorithm}
			
			Pour les algorithmes de parcours et d'extraction de voisins, tous les algorithmes proposés dans \citep{hernandez2014compressed} peuvent être appliqués sur notre structure. En effet, le seul changement consiste en la  prise en compte de l'information temporelle dans l'incrémentation des indices de parcours. De ce fait, nous pensons que notre méthode peut offrir un très bon compromis entre l'espace mémoire et le temps d'accès des traitements dans le cas des graphes dynamiques. 
			
		\section{Conclusion}
	Dans ce chapitre, nous avons abordés le problème de compression des graphe dynamique par extraction de motifs. Nous avons formaliser le problème de compression d'un graphe dynamique en se basant sur les sous-graphes denses temporelles qui le composent. Pour faire face a ce problème nous avons présenter une nouvelle méthode hybride intitulé DDSM, elle combine entre deux méthodes de la littérature que nous avons juger efficaces. Notre prochain but est de tester cette méthode en la comparant avec les méthodes existantes.   

	
	
	
	%\begin{defn}
	%		Here is a new definition
	%\end{defn}
	

%Conclusion Générale									Obligatoire


\newpage

	\par
		\vskip 1in
		\Huge 
			\textbf{Conclusion générale} \\[0.5in]
			\addcontentsline{toc}{chapter}{\numberline{}Conclusion générale}
		
		\normalsize
		
	La situation d'abondance d'information aujourd'hui a favorisé l'incapacité d'assimilation et de réemploi de l'information et a montré l'inadaptation des outils de gestion classiques. Une des solution les plus connus pour pallier à ce problème est la compression.\\
		
		Nous nous sommes intéressés dans ce travail aux domaines de compression de graphes, et plus particulièrement les méthodes de compression par les k2-trees et les méthodes de compression par extraction de motifs. Nous avons présenté les différentes méthodes de compression existantes et nous avons établi une étude comparatif entre eux. Nous avons aussi essayer de rectifier la classification des proposées dans un travail de master précédent. Une dernière contribution que nous avons apporter consiste en une nouvelle méthode de compression par extraction de motifs usant des structures k2-trees.\\  
	
	Cette étude nous a amené à constater que malgré le progrès existant dans ce domaine plusieurs défis, tel que :la compression temps réelle et les temps de traitements, sont encore présents. Ces défis constitues de nouvelles problématiques de recherche qui sont toujours ouvert.\\
	
	Nous nous focaliserons dans le future à implémenter ces méthodes et leurs variantes. Cette implémentation nous permettra de mieux comparer entre ces méthodes en employant le même jeux de données. De ce fait nous pourrons établir une comparaison plus objective entre eux.

\newpage
\bibliography{Bibliographie}
\bibliographystyle{apalike}

\end{document}

%\renewcommand{\thefigure}{\arabic{figure}}
%\setcounter{figure}{0}
%\begin{figure}[H]
%	\centering
%	\includegraphics[scale=1]{ressources/image/LAAS-2016.jpg}
%	\label{fig:figure1}
%	\caption{This is a teste of figure}
	
%\end{figure}








