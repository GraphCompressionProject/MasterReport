\chapter{Test}
	\section{Introduction}
	
Dans ce chapitre, nous exposerons les différents résultats de mesures de performances obtenus par nos deux moteurs $k^2$-GraCe et P-GraCe en utilisant plusieurs datasets dans différentes configurations. Nous commencerons par présenter l'environnement de test et les conditions d'expérimentation ainsi que les graphes utilisés. Nous allons par la suite présenter les résultats obtenus pour chaque méthode séparément et comparer par la suite entre les deux moteurs k2-GraCE et P-GraCE. 


	
	
	\section{Environnement de Test}
	L'environnement de test compte parmi les éléments sur lesquels repose l'optimisation de tout système. C'est un environnement permettant de tester les différentes configurations et modules. Nous présenterons dans cette partie les caractéristiques matérielles et logicielles de l'environnement de test utilisé durant nos expériences. 

	
	\begin{itemize}[label=$\bullet$]
		\item \textbf{Nombre de processeurs :}	1
		\item \textbf{Processeur :} Intel Core i7 (2,2 GHz)
  		\item \textbf{Nombre total de cœurs :}	2
  		\item \textbf{Cache de niveau 2 (par cœur) :}	256 Ko
  		\item \textbf{Cache de niveau 3 :}	4 Mo
		\item \textbf{RAM : } 8 Go 1600 MHz DDR3
		\item \textbf{Système d'exploitation : } Windows 10
	\end{itemize}
	\section{Présentation des graphes de test}
	Nous allons dans cette section présenter les graphes de test utilisés pour l'évaluation de nos deux moteurs $k^2$-Grace et P-Grace. 
	 Le tableau \ref{graphTest} regroupe les différents graphes. La première colonne classe les graphes selon leur type : Statique non orienté étiqueté, Statique non orienté non étiqueté, Statique  orienté et Dynamique orienté. Cette diversité revient à la particularité des graphes pris en entrées et leur caractéristiques qui diffèrent d'une méthode à une autre.
Nous fournissons également une présentation des domaines d'application à partir desquels  les graphes sont issus. Le tableau donne également les caractéristiques de chaque graphe représentés par le nombre de nœuds et le nombre de liens. 
	 

	\begin{table}[H]
\begin{tabular}{|c|c|c|L{4cm}|l|l|L{4cm}|}
\cline{1-7}
\multicolumn{3}{|l|}{Type de graphe}                                                  & Graphe                        & Nb. noeuds             & Nb. liens               & Description                                                                        \\ \cline{1-7}
\multirow{11}{*}{\rotatebox[origin=c]{90}{ Statique } } & \multirow{7}{*}{ \rotatebox[origin=c]{90}{ Non Orienté } } & \multirow{4}{*}{ Étiqueté}    & vote-r \citep{subd}                       & 1266                   & 6451                    & Représentation graphique d'une base de données présente dans le référentiel UCI \\ \cline{4-7}
                           &                          &                               & diabetes \citep{subd}                      & 4500                   & 4000                    & Représentation graphique d'une base de données présente dans le référentiel UCI \\ \cline{4-7}
                           &                          &                               & ttt-win  \citep{subd}                     & 5634                   & 10016                   & Base de données Tic Tac Toe générée de manière exhaustive                          \\ \cline{4-7}
                           &                          &                               & credit \citep{subd}                       & 14700                  & 14000                   & Représentation graphique d'une base de données présente dans le référentiel UCI \\ \cline{3-7}
                          
						   &                          & \multirow{3}{*}{Non Étiqueté } & ca-netscience  \citep{caNetScience}                        & 379                    & 914                     & Réseaux de collaboration                                                              \\ \cline{4-7}
                           &                          &                                                & Choclate  \citep{koutra2015summarizing}                      & 2899                  & 5467                   &                        Graphe  co-authorship                                                 \\ \cline{4-7}
                           &                          &                                 & Caida  \citep{caida}                      & 26475                  & 53381                   & Réseaux routier                                                                \\ \cline{2-7}
                       
                          
						  
						  
						   & \multicolumn{2}{l|}{\multirow{5}{*}{Orienté }}        &       bio \citep{snapnets}              & 490                    & 4598                    & Graphe de Biologie                                                          \\ \cline{4-7}
                            & \multicolumn{2}{l|}{}                                 & web-edu                       & 3031                   & 6474                    & Graphe du web                                                    \\ \cline{4-7}
                           & \multicolumn{2}{l|}{}                                   & web-polblogs  \citep{rep1}                & 644                    & 2280                    & Graphe du Web                                                                         \\ \cline{4-7}
                           & \multicolumn{2}{l|}{}                                    & wiki-Vote   \citep{snapnets}                  & 7115                   & 103689                  & Graphe des réseaux sociaux                                                               \\ \cline{1-7}
                         
\multirow{3}{*}{ \rotatebox[origin=c]{90}{ Dynamique }} & \multicolumn{2}{l|}{\multirow{3}{*}{  Orienté }}            & aves-weaver-social \citep{rep1}   & 441                    &                         & Réseaux sociaux                                                                    \\ \cline{4-7}
                           & \multicolumn{2}{l|}{}                                    & reptilia-tortoise-network-bsv \citep{rep1} & 360                    &                         & Réseaux d'interaction des animaux                                                  \\ \cline{4-7}
                           & \multicolumn{2}{l|}{}                                    & reptilia-tortoise-network-fi  \citep{rep1}& 784                    &                         & Réseaux d'interaction des animaux                                                  \\ \cline{1-7}
\end{tabular}
\caption{Description des Graphes de Tests}
\label{graphTest}
\end{table}
	
	
	Nous fournissons ci-après plus de détails sur la description des graphes et leurs domaines d'application :
	\begin{itemize}
	
	
	\item \textbf{Graphes de Biologie :} sont des graphes représentant les interactions entre les molécules.
	
	\item \textbf{Graphes du web :} Ces graphes  modélisent les pages du web. Les nœuds de ce graphe représentent des pages html et ses arcs représentent l'existence d'un hyperlien d'une page vers une autre.  

	\item \textbf{Graphes des réseaux sociaux :} Ce type de graphe représente les interactions entre individus dans différentes plateformes. Ils peuvent modéliser des relations symétriques entre eux comme l'amitié, avec des graphes non orientés, ou des relations asymétriques, comme l'envoie de messages, avec des graphes orientés.

	\item \textbf{Graphes de collaboration :} Ces réseaux représentent les individus travaillant sur un projet. Un lien entre deux individus dans ce cas signifie qu'ils travaillent ensemble sur une ou plusieurs parties du projet. 

	\item \textbf{Graphes des réseaux routier :}  Les nœuds dans ces graphes représentent les villes et les liens représentent les routes existantes entre eux.
	
	\item \textbf{Graphes des réseaux d'interaction des animaux :} Ensembles de données du réseau d'interaction animale dans le monde réel. Ces données proviennent d'études publiées sur des animaux sauvages, captifs et domestiques.
	
	
	\end{itemize}
	
	\section{Évaluation du moteur $k^2$-GraCE}
	Nous allons dans cette partie présenter une évaluation des méthodes du moteur $K^2$-Grace. 
	Nous commencerons par étudier l'impact du type de représentation utilisée dans la construction de l'arbre sur le temps d'exécution. Nous nous intéresserons par la suite à l'étude de l'influence du paramètre K sur les performances de compression.
	Finalement, nous  analyserons  l'impact  du module pré-traitement sur la qualité de compression. 
	\subsection{Étude de l'effet de la représentation du graphe en entrée}
			
				\begin{figure}[H]
		\begin{center}
			%\subfloat[{Bio. \label{fig:testdom2}}]
			%{\includegraphics[scale=0.5]{ressources/image/Tests/rep-bio.png}}\hspace{3em}
			%\subfloat[{web-edu. \label{fig:testdom1}}]
			%{\includegraphics[scale=0.5]{ressources/image/Tests/rep-web-edu.png}}\hspace{3em}
			%\subfloat[{web-polblogs. \label{fig:testdom3}}]
			%{\includegraphics[scale=0.5]{ressources/image/Tests/rep-web-polblogs.png}}\hspace{3em}
			
			\includegraphics[scale=0.6]{ressources/image/Tests/tst.jpg}
			\caption{Résultats de tests du moteur $K^2$-Grace selon les différents types de représentations du graphe en entrée.}
			\label{fig:test-rep}
		\end{center}
	\end{figure}
			
Les graphes de la figure  \ref{fig:test-rep} représentent la variation du temps d'exécution de la méthode $k^2$-trees selon les différentes représentations du graphe en entrée  sur trois graphes de tests : Bio, web-edu et web-polblogs. Cette compression a été effectuée avec un ordre initial et avec différentes valeurs de k. 

Nous constatons d'après les trois figures que l'utilisation des trois représentations donne des temps d'exécution totalement différents. Nous remarquons que si l'écart existant dans le temps d'exécution  entre l'utilisation de la matrice d'adjacence  et les deux autres structures peut être acceptable pour les petits graphes comme bio qui comptent 490 nœuds, il ne peut être toléré pour le cas des grands graphes comme web-edu et web-polblogs.
En effet, nous avons obtenu, dans le cas du graphe bio, un temps d'exécution entre 2 et 3 secondes dans le cas de l'utilisation de la matrice d'adjacence et un temps d'exécution entre 0,015 et 0,4 seconde dans les deux autres cas. Cependant, le cas du graphe web-polblogs donne un temps d'exécution de 38 minutes pour k=2 lorsque le l'arbre est construit en utilisant la matrice d'adjacence et un temps d'exécution de 0,03 secondes dans le cas des deux autres structures. Nous pensons que cela revient au temps que prend la machine pour charger la matrice d'adjacence en mémoire centrale qui devient de plus en plus important lorsque la taille du graphe est grande. De ce fait, nous utiliserons uniquement la structure TNGraph pour la suite des tests.

			\subsection{Analyse de l'impact du paramètre k}
			Les figures \ref{fig:K2-paraK-NBbits} et\ref{fig:K2-paraK-Ratio} représentent respectivement l'évolution du nombre de bits par nœud et du ratio de compression en fonction des différentes valeurs du paramètre K. La compression a été appliquée sur différents graphes de test statiques issus de plusieurs domaines et avec différentes caractéristiques pour avoir une meilleure analyse. Les graphes utilisés dans ce test sont : bio, web-edu, web-polblogs, wiki et soc-Epinions. Cette compression a été effectuée avec un ordre initial et sans aucun pré-traitement.
%, avec comme paramètres :  (a voir aprés avec hafsa les noms des par).
 Nous avons varié le paramètre K entre 2 et 16.
			
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{ressources/image/Tests/K2-paraK-Ratio.png}
	
	\caption{Résultats de compression de $K^2$-Grace : Ratio de compression du moteur $K^2$-Grace en fonction du paramètre K (cas statique)}
	\label{fig:K2-paraK-Ratio}
\end{figure}

D'après les résultats obtenues dans la figure \ref{fig:K2-paraK-Ratio}, nous remarquons que le ratio de compression diminue quand k prend des valeurs plus grandes et atteint sa valeur minimale (exemple : 20 pour soc-Epinions) quand K=16. Ainsi, nous constatons que plus le k est petit plus le ratio de compression est optimal. En effet, pour des petites valeurs de K, l'arbre a plus de niveaux, mais il est moins large et le nombre de ses feuilles est plus petit (petites sous matrices finales) ce qui réduit la taille de l'arbre et donne une meilleur qualité de compression. Nous avons pu aussi confirmer cette hypothèse avec le nombre de bits par nœuds obtenu dans les différents cas et qui est représenté dans la figure \ref{fig:K2-paraK-NBbits}. Nous observons que le nombre de bits par nœud augmente de manière exponentielle en fonction du k et atteint sa valeur maximale (exemple 917 938 bits par nœud dans le cas du graphe wiki) quand K est à 16. Le nombre de bits augmente avec les grandes valeurs de k reflétant ainsi une augmentation dans la taille du graphe en sortie.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{ressources/image/Tests/K2-paraK-NBbits.png}
	
	\caption{Résultats de compression de $K^2$-Grace : Nombre de bits par nœuds en fonction du paramètre K}
	\label{fig:K2-paraK-NBbits}
\end{figure}		


Nous nous sommes aussi intéressées à l'étude de l'effet du paramètre k sur les performances de compression dans le cas des graphes dynamiques. Nous présentons dans la figure \ref{fig:K2-dyn-paraK-NBbits} les résultats obtenus pour ce type de graphe. Les graphes utilisés dans ce test sont : aves-weaver-social, reptilia-tortoise-network-bsv et reptilia-tortoise-network-fi. Ces graphes sont représenté avec leur captures initiales (sans aucun pré-traitement).

A partir de la figure \ref{fig:K2-dyn-paraK-NBbits}, nous remarquons une dégradation des performances dans le cas général. Cependant, nous obtenons les meilleurs performances pour k=8 dans le cas des deux graphes aves-weaver-social et reptilia-tortoise-network-bsv avec un 1,87 bits par nœud pour le premier graphe et 1,78 bits par nœud pour le deuxième graphe. De ce fait, l'hypothèse que nous avons avancée dans le cas des graphes statiques ne peut être généralisée dans le cas des graphes dynamiques où nous avons obtenu différentes valeurs optimales de k dans les différents graphes. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.38]{ressources/image/ratioik2.png}
	
	\caption{Résultats de compression de $K^2$-Grace : Nombre de bits par nœuds et Ratio de compression  du moteur en fonction du paramètre K (cas dynamique)}
	\label{fig:K2-dyn-paraK-NBbits}
\end{figure}	
	

La figure \ref{fig:K2-Texec} représente l'évolution du temps d'exécution en fonction du paramètre K. Dans le cas des graphes statiques, nous notons que le temps de compression varie de manière aléatoire et ne dépend pas de la valeur de K. En effet, dans le cas des graphes bio et soc-Epinions nous obtenons des temps d'exécution qui changent de manière aléatoire. Tant dis que dans le cas du graphe web-edu nous obtenons un temps d'exécution qui diminue en fonction de k contrairement au graphe wiki-Vote dans lequel le temps d'exécution  augmente en fonction du paramètre k. Dans le cas des graphes dynamiques, nous remarquons que le temps d'exécution diminue jusqu'à k=8 où il atteint sa valeur minimale pour k=8 et commence à augmenter à partir de cette valeur.


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{ressources/image/Tests/K2-Texec.png}
	
	\caption{Résultats de compression de $K^2$-Grace : Temps de compression en fonction de K}
	\label{fig:K2-Texec}
\end{figure}


			
			
 \subsection{Étude de l'apport de la phase de pré-traitement }
 
 Durant cette partie de l'évaluation du moteur $k^2$-GraCE, nous nous focaliserons sur l'étude de l'effet de l'utilisation des techniques du module << pré-traitement >> du moteur $k^2$-GraCE. Nous commencerons par étudier l'effet des différents ordres des nœuds dans le cas des graphes orientés. Nous enchainerons par la mesure du gain apporté par la considération de la partie supérieure uniquement de la matrice d'adjacence dans la construction de l'arbre $k^2$-tree pour le cas des graphes non orientés. Finalement, nous présenterons les tests relatifs à l'utilisation d'une matrice de différence dans le cas des graphes dynamiques.
 			
\subsubsection{Étude de l'effet de l'ordre}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{ressources/image/Tests/k2-ordre.png}
	\caption{Résultats de compression de $K^2$-Grace :Ratio de compression selon l'ordre des nœuds}
	\label{fig:K2-ordre }
\end{figure}		

La figure \ref{fig:K2-ordre } représente l'évolution du ratio de compression du moteur $k^2$-Grace sur quatre graphes de test : bio, web-edu, web-polblogs et wiki. Cette compression a été effectuée en utilisant cinq ordres différents : BFS, DFS, Gray, Lexical et Random avec comme paramètre k=2. Nous remarquons que dans le cas des deux graphes web-edu et web-polblogs qui sont des graphes du web , nous avons obtenu une détérioration des performances de compression pour les différents ordres. Nous justifions cela par le fait que les arbres $k^2$-trees ont été au départ conçus pour exploiter les propriétés de l'ordre initial des nœuds dans la matrice d'adjacence. Cependant, nous remarquons que dans le cas du graphe wiki-Vote, qui est un graphe issu du domaine des réseaux sociaux, nous avons obtenu une amélioration du ratio initial d'un facteur de 1,4 avec les ordres : \gls{dfs}, \gls{bfs}, Gray et Lexical. Pour ce graphe, nous avons obtenu un ratio de compression optimal de 49 pour l'ordre BFS. Dans le cas du graphe bio, nous remarquons que uniquement les ordres Lexical et gray ont permis de garder les même performances que l'ordre initiale. Nous constatons donc que ces ordres donnent de bonnes performances avec les graphes qui ne sont pas issus du domaine du web. En effet, comme nous l'avons déjà noté s'ils ne permettent pas d'améliorer les performances ils ne les détériorent pas.


\subsubsection{Étude de l'effet de l'utilisation de la partie supérieure uniquement de la matrice d'adjacence}


Le tableau \ref{fig:tab-pret } donne les résultats de la compression du moteur $k^2$-Grace appliqué sans et avec pré-traitement sur des graphes non orientés avec un k=2 et un ordre initial des nœuds. Les graphes utilisés sont ChocWIki, ca-netscience, Caida. 
 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{ressources/image/Tests/tab-pret.png}
	\caption{Résultats de compression de $K^2$-Grace avec/sans pré-traitement (cas non orienté)}
	\label{fig:tab-pret }
\end{figure}

Nous observons que le ratio de compression et le nombre de bits par nœud sont nettement meilleurs avec le pré-traitement. Le pré-traitement appliqué sur le graphe non orienté maximise les zones vides dans la matrice d'adjacence en diminuant le nombre de 1 de la moitié ce qui réduit la taille de l'arbre et produit une meilleure qualité de compression. Nous remarquons cela dans le ratio de compression qui double pour les trois graphes. Le temps d'exécution est presque le même entre les deux exécutions car nous construisant la matrice triangulaire supérieure au moment de la lecture directement. Le léger écart noté entre les deux exécutions est du aux comparaisons des indices sources et destinations effectuées pour construire la matrice. 

La figure \ref{fig:gain } présente le gain obtenu après l'application du pré-traitement sur les graphes non orientés, nous remarquons que le gain est aux alentours du double pour tous les graphes. Cela prouve que le pré-traitement améliore clairement la qualité de compression tout en offrant la possibilité d'extraire toutes les informations incluses dans le graphe original.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{ressources/image/gain.png}
	
	\caption{Gain de compression de $K^2$-Grace avec le pré-traitement}
	\label{fig:gain }
\end{figure}


\subsubsection{Étude de l'effet de l'utilisation d'une matrice de différence}

Dans cette partie, nous évaluerons l'effet de l'utilisation de la matrice de différence pour la construction de l'arbre sur les performances de compression. Comme les tests précédents ont montré  qu'il n'existe pas de valeur optimale pour le k qui améliore ces derniers, nous effectuerons les tests de cette phase pour différentes valeurs de k. Le tableau de la figure \ref{res-dyn-tst} donne les valeurs des trois (03) métriques considérées en fonction des valeurs de k.


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.48]{ressources/image/ik2.png}
	\caption{Résultats de compression de $K^2$-Grace avec/sans pré-traitement (cas dynamique)}
	\label{res-dyn-tst}
\end{figure}

Nous remarquons que nous obtenons dans tout les cas un temps d'exécution presque égale. Le léger écart noté dans le cas de l'utilisation du pré-traitement représente le temps nécessaire pour le calcule de la matrice de différence. 
Pour le graphe aves-weaver-social, nous remarquons que le ratio de compression (resp. le nombre de bits par nœud) diminue (resp. augmente) de moitié (resp. du double) pour toute les valeurs de k. Pour le deuxième graphe reptilia-tortoise-network-bsv, nous observons bien que les performances (ratio et nombre de bits par lien) restent les même dans les deux cas sans et avec pré-traitement. Tant dis que dans le cas du troisième graphe, nous remarquons que nous obtenons les mêmes performances pour k=2 et que nous perdons en performances quand le k prend des valeurs plus grandes. Pour mieux illustrer ces observation nous fournissons dans la figure \ref{perte } la courbe représentant le rapport entre le ratio de compression avant et après l'utilisation du pré-traitement. 


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{ressources/image/perteIk2.png}
	
	\caption{Ratio de avec pré-traitement/ Ratio de sans pré-traitement}
	\label{perte }
\end{figure}

Nous constatons donc que l'utilisation de ce module n'a pas amélioré les performances de compression dans le cas des trois graphes. Cela est du à la nature de leur captures successives qui ne partagent presque aucun lien en commun engendrant ainsi soit la même matrice initiale ou une matrice de différence plus dense que celle du graphe original.



	\section{Évaluation du moteur P-GraCE}
	
	Nous évaluerons, dans cette partie, les quatre approches de compression par extraction de motifs incluses dans le moteur P-GraCE. 
	Dans un premier temps, nous étudierons aussi le rondement du beam-search en fonction du niveau d'agrégation.  Nous enchainerons par la suite avec l'évaluation des performances de compression par extraction de motifs en utilisant des méthodes de détection de communautés. Nous aborderons par la suite l'approche basée sur les propriétés de la matrice d'adjacence où nous allons étudier l'influence du type et de la taille des motifs sur les mesures de performances.
	Finalement, nous présenterons les différents tests relatifs à la méthode de compression que nous avons proposée: DDSM qui est destinée aux graphes dynamiques.
	\subsection{Évaluation de l'algorithme du beam-search :}
	
  Durant cette section, nous considérons le cas des graphes non orientés et étiquetés. Nous évaluerons le rondement de compression de l'algorithme du beam-search sur ces derniers tout en prêtant attention au temps d'exécution. Le tableau ci-dessous résume les résultats obtenus.
  

	\begin{figure}[H]
	
			
			\includegraphics[scale=0.37]{ressources/image/beam.png}
			
			\caption{Résultats des tests du beam-search.}
			\label{fig:test-beam}
	
	\end{figure}
	
	%%% Ajouter le tableau des resulats obtenus 
	
	  La figure \ref{fig:test-beam} illustre les résultats de test obtenus pour différents graphes en fonction du nombre d'itérations de l'algorithme (le niveau d'agrégation). Nous constatons une amélioration du ratio de compression dans la majorité des cas. En contre partie, nous remarquons que le temps d'exécution  augmente surtout dans le cas des grands graphes (exemple du graphe credits). Le choix du nombre d'itérations (niveau de la hiérarchie d'agrégation) dépend des performances voulues. Cependant, nous pensons qu'un  nombre d'itération égale 70 offre déjà un bon compromis entre le temps d'exécution et le ratio de compression.
	
	\subsection{Évaluation des techniques basées sur les méthodes de clustering :}
	
	Dans cette partie, nous proposons de tester les méthodes de compression basées sur les techniques de clustering en faisant varier différents paramètres. Dans un premier temps, nous fixerons  Slashburn comme méthode d'extraction de motifs et nous évaluerons les performances de compression obtenus avec la méthode de sélection topk en considérant à chaque fois une portion uniquement des structures découvertes (k=25\%,k= 33,33\%, k=50\%, k=100\%). Par la suite, nous étudierons l'effet  du choix de la méthode de sélection sur la qualité de compression en  utilisant la même méthode d'extraction de motifs. Finalement, nous analyserons l'effet de la méthode de clustering sur les résultats en fixant cette fois la méthode \textit{step} comme méthode de sélection.
	
	
		
		\subsubsection{Étude de l'influence du nombre de structures sélectionnées :}
	
		
		\begin{figure}[H]
	
			
			\includegraphics[scale=0.6]{ressources/image/vogStat.jpg}
			
			\caption{Résultats des tests de l'influence du nombre de structures sélectionnées.}
			\label{fig:test-select}
	
	\end{figure}
	
	La figure \ref{fig:test-select} illustre les mesures des trois métriques : ratio de compression, nombre de bits par nœud et le temps d'exécution en considérant différentes portions des sous-structures découvertes. Nous remarquons que le ratio de compression est presque équivalent pour les différentes valeurs de k. Cependant, nous observons bien que la considération de toutes les structures donne un meilleur ratio de compression de 1,06 pour chocWiki, de 1,23 pour netscience et de 1,03 pour le graphe Caida. Cette hypothèse peut être facilement confirmée avec le nombre de bits par noeud qui atteint sa valeur minimale avec la méthode \textit{Plain}. Quant au temps d'exécution, nous constatons  que la méthode \textit{Plain} offre toujours de meilleur performance. En effet, la méthode \textit{topk} ordonne les sous-structures selon le gain d'encodage local avant la sélection engendrant ainsi un temps supplémentaire contrairement à la méthode \textit{plain} qui sélectionne toutes les sous-structures sans aucun ordre. 
		
		\subsubsection{Étude de l'influence de la méthode de sélection :}
		
		\begin{figure}[H]
	
			
			\includegraphics[scale=0.7]{ressources/image/vogcond.jpg}
			
			\caption{Résultats des tests de l'influence de la méthode de sélection.}
			\label{fig:test-vogcond}
	
		\end{figure}
		
		Dans cette partie, nous présenterons les tests relatifs à l'utilisation de trois méthodes de sélection : Step, \gls{gnf} et \textit{Plain}. La figure \ref{fig:test-vogcond} résume les résultats obtenus sur  trois graphes non orientés statiques.
		
		Nous remarquons que la méthode Step donne de meilleur performances de compression avec un ratio maximale de 1,26 pour le graphe netscience qui compte 379 nœuds. En effet, si nous voulons classer ces méthodes de sélection selon les résultats du ratio et le nombre de bits par nœud nous obtenons le classement suivant: Step, \textit{Plain} et \gls{gnf} et ce pour tout les graphes utilisés dans ce test. Par contre, nous remarquons que la méthode Step donne un temps d'exécution qui est très élevé par rapport aux deux autres méthodes surtout dans le cas des grands graphes. Par exemple dans le cas du graphe Caida, nous avons obtenu un temps d'exécution de plus de quatre (04) heures avec la méthode Step  contre un temps d'exécution entre une (01) et deux (02) minutes pour les deux autres méthodes pour une amélioration de 0,04 dans le ratio de compression.
		
		\subsubsection{Étude de l'influence de la méthode de clustering :}	
		
		\begin{figure}[H]
			\centering
			
			\includegraphics[scale=0.7]{ressources/image/clustmthd.png}
			
			\caption{Résultats des tests de l'influence de la méthode de clustering .}
			\label{fig:test-clustmtd}
	
	\end{figure}	
		
	
	Dans ce dernier test, nous nous sommes intéressées à voir le gain apporté par la méthode de clustering dans le ratio de compression. La figure \ref{fig:test-clustmtd} illustre les résultat obtenus. Nous avons considéré trois (03) méthodes de clustering: Slashburn, Spectral et K-cores. 
	
	Selon le graphe, les deux méthodes de compression Spectral et K-Cores donnent de meilleur résultat que SLashburn pour les différents graphes. En effet, dans le cas du graphe ChocWiki la méthode spectrale donne le meilleur ratio (1,30). Tant dis que dans le cas des deux autres graphes, netscience et Caida, la méthode K-cores donne un meilleur ratio de 1,35 et 1,18 respectivement. Cependant, la combinaison des trois méthodes d'extraction de motifs donne une amélioration significative du ratio dans les trois graphes de test.
	
	%Nous mesurons aussi le nombre de sous-strcuture dans chaque cas que nous accompagnons dans le tableau en dessous de la figure \ref{fig:test-clustmtd}. Nous remarquons que Slashburn donne dans tous les cas un nombre plus grands de sous-structures que les deux autres méthodes.
	
	
	
	\subsection{Étude de l'influence du type et de la taille des motifs dans les méthodes basées sur la matrice d'adjacence :}
	
	Durant cette partie, nous présenterons les résultats obtenus lors de l'évaluation de l'extraction de motifs à partir de la matrice d'adjacence. La figure \ref{fig:test-m} illustre l'évolution du ratio de compression en fonction de la taille du motif pour les trois classes offertes par le moteur P-GracE.
		\begin{figure}[H]
		\begin{center}
		
			\includegraphics[scale=0.55]{ressources/image/m12.jpg}
			
			
			
			\caption{Le ratio de compression en fonction de la taille du motif.}
			\label{fig:test-m}
		\end{center}
	\end{figure}
	
	Dans le cas de la première et la troisième classe de motifs, nous remarquons une amélioration du ratio de compression lorsque leur taille prend des grandes valeurs. Cette observation est du au gain obtenu en remplaçant des motifs de taille $2^n$ bits par \textit{n} bits pour la premier type de motfs et \textit{n+1} bits pour le troisième, par exemple les motifs de taille 256bits seront remplacés par uniquement 8bits dans le cas de la classe (01) et par 9bits dans le cas de la classe (03). Pour la deuxième classe de motif, le ratio de compression est resté presque constant pour différentes valeurs de la taille des motifs. Nous remarquons aussi que ce dernier au tour de 1 dans la majorité des cas signifiant ainsi que le taille du graphe en sortie est presque équivalente à la taille du graphe initial. Ce résultat ne peut être obtenu que dans le cas où peu de motifs ont été trouvés dans la matrice d'adjacence. Nous constatons donc que les motifs de cette deuxième classe ne sont pas fréquents dans les matrices d'adjacence des graphes réels. 
	
	
	
	%\subsection{Évaluation de l'utilisation des méthodes de clustering :}
	
	
	
	
	\subsection{Évaluation de la méthode DDSM :}
	
	Nous présenterons dans cette partie, les tests relatifs à la méthode que nous avons proposée. Nous étudierons les performances obtenues en fonction du nombre de permutations utilisées dans le processus de découverte et d'étiquetage des sous-structures. 
\begin{figure}[H]
	
	\includegraphics[scale=0.4]{ressources/image/grDDSM.png}
	\label{fig:perte }
	\caption{Résultats de la méthode DDSM}
\end{figure}
		\begin{figure}[H]
		\begin{center}
		 \includegraphics[scale=0.45]{ressources/image/DDSM.jpg}
			
			
			\caption{Résultats des tests de la méthode DDSM.}
			\label{fig:test-ddsm}
		\end{center}
	\end{figure}
	
	Nous remarquons que la méthode proposée offre de très bon résultats par rapport au temps d'exécution qui ne dépasse pas une (01) seconde pour toutes les exécutions. Pour le ratio de compression, nous constatons une amélioration significative qui commence à se stabiliser à partir du moment où le nombre de permutations dépasse 50. 
	
	\begin{figure}[H]
		
		 \includegraphics[scale=0.38]{ressources/image/statDDSM.png}
			
			
			\caption{Statistique des différentes types de sous-structures découvertes}
			\label{fig:stat-DDSM}
		
	\end{figure}	
	
	Nous fournissons dans la figure \ref{fig:stat-DDSM} les différentes sous-structures découvertes pour un exemple d'exécution avec 50 permutations. Dans le cas du graphe Aves-weaver-social, nous remarquons que nous obtenons 30 sous-structures denses qui apparaissent de manière périodique et une seule sous-strcuture qui apparait de manière aléatoire. Les sous-structures périodiques représentent donc des utilisateurs du réseaux qui s'envoient des messages  périodiquement (exemple: réunion dans un contexte de télé-travaille, des groupes d'étude, ...). Dans les deux autres réseaux qui font parties des réseaux d'interaction des animaux nous remarquons des sous-structures constantes qui représente peut être des animaux appartenant à un même troupeau. Nous observons aussi des sous-strcutures périodiques qui peuvent être interprétées comme des chasses d'animaux pour la nourriture. Un autre type sont les sous-structures qui apparaissent dans une seule période représentant en générale le phénomène de couplage chez les animaux dans des périodes bien précises.
	
	DDSM offre ainsi non pas uniquement la compression du graphe initial mais aussi la possibilité de l'analyser et d'interpréter les informations les plus pertinentes incluses dans ce dernier.
	
	\section{Comparaison entre les différentes méthodes:}
	
	Après avoir évaluer les différentes configurations possibles des deux moteurs : $k^2$-GraCE et P-GraCE, nous nous intéresserons dans cette partie à établir une étude comparative entre les méthodes implémentées dans les deux moteurs ainsi que les classes auxquelles elles appartiennent. Cette partie sera donc organisée en trois sous-sections chacune englobant les méthodes de compression acceptant le même type de graphe en entrée.
	
	\subsection{Évaluation des méthodes destinées aux graphes orientés statiques :}
\begin{figure}[H]
		\begin{center}
		 \includegraphics[scale=0.4]{ressources/image/compNon.png}
			
			
			\caption{Comparaison entre les méthodes destinées aux graphes statiques orientés.}
			\label{fig:comp-dyn}
		\end{center}
	\end{figure}	
	
	Nous considérons dans cette partie les graphes orientés: bio, web-edu et web-polblogs, pour comparer entre trois méthodes de compression destinées pour ce type de graphe: $k^2$-GraCE, l'approche du Minhashing et enfin l'approche basée sur la matrice d'adjacence. Nous utiliserons pour cela deux métriques : le ratio de compression (figure à gauche) et le temps d'exécution (figure à droite). Nous remarquons que le moteur $k^2$-GraCE donne les meilleurs résultats en terme d'espace mémoire (le meilleur ratio). Cependant, il donne le plus grand temps d'exécution. Nous observons aussi que les deux autres méthodes donnent des résultats presque équivalents dans le des graphes bio et web-polblogs, et que la technique du Minhashing donne un meilleur résultat dans le cas du graphe web-edu avec un ratio de 112 vs un ratio de 26 pour la méthode basée sur la matrice d'adjacence. 
	
	\subsection{Évaluation des méthodes destinées aux graphes non orientés statiques :}
	
	\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{ressources/image/vogk2.png}
	\caption{Comparaison entre les méthodes destinées aux graphes statiques non orientés.}
	\label{fig:K2-vog}
\end{figure}	

	La figure \ref{fig:K2-vog}  donne les résultats de compression: ratio et temps de compression des deux méthodes de compression des moteur P-GraCE et $k^2$-GraCE dans le cas des graphes non orientés statiques. Nous utilisons dans ce test les graphes : ChocWiki, Caida et netscience. Pour le moteur $k^2$-GraCE, nous fixerons la valeur de k à 2 en considérant uniquement la partie supérieure de la matrice d'adjacence. Tant dis que pour le moteur P-GraCE, nous utiliserons l'approche basée sur la méthode de clustering avec Spectral comme méthode de clustering et la méthode \textit{step} comme méthode de sélection.
	
	D'après l'illustration, nous observons que le ratio de compression du moteur $k^2$-GraCE  est nettement meilleur que celui du moteur P-GraCE. Nous citons l'exemple du graphe Caida qui comptent 26475 nœuds et 53381 arêtes où nous obtenons un ratio de compression de 879 dans $k^2$-GraCE contre un ratio de 1,17 avec le moteur P-GraCE. Quant au temps d'exécution, nous remarquons que le moteur P-GraCE  est beaucoup plus rapide par rapport à $k^2$-GraCE surtout dans lorsque la taille du graphe devient grande (exemple du graphe Caida).
 
	
	\subsection{Évaluation des méthodes destinées aux graphes dynamiques :}
	
	Dans cette partie, nous allons comparer entre les deux méthodes de compression destinées aux graphes dynamiques qui sont incluses, la première dans le moteur $k^2$-GraCE et la deuxième dans le moteur P-GraCE consistant en un nouveau schéma de compression que nous proposons. La figure \ref{fig:comp-dyn} montre les résultat des deux méthodes de compression en choisissant les valeurs optimales de leurs paramètres.
	
	\begin{figure}[H]
		\begin{center}
		 \includegraphics[scale=0.4]{ressources/image/dynComp.png}
			
			
			\caption{Comparaison entre les méthodes destinées aux graphes dynamiques.}
			\label{fig:comp-dyn}
		\end{center}
	\end{figure}
	
	
	Nous remarquons que la ratio de compression est meilleur dans le moteur $k2$-GraCE. En effet, la méthode DDSM donne un ratio de compression très faible en le comparant avec le moteur $k^2$-GraCE (exemple: 3689 vs 129 pour le graphe aves-social-network). Cependant, nous observons bien que le temps d'exécution est nettement meilleur dans le cas de notre méthode. Nous rappelons aussi que notre méthode permet d'extraire les sous-graphes et les communautés les plus denses (les plus importantes) ainsi que leur comportement temporel avec un accès direct alors que le moteur $k^2$-GraCE nécessite un traitement supplémentaire qui peut être lourd dans le cas des grands graphes. 
	
	 
	
	\section{Synthèse des tests}
	
	A travers ce chapitre,  nous avons pu évaluer nos deux moteurs tout en étudiant l'effet de différentes configurations sur leur performance. Des datasets de domaines hétérogènes ont été employés durant cette étape afin de déduire l'influence de ces derniers sur le choix de l'algorithme de compression. Nous avons opté pour trois métriques d'évaluation : ratio de compression, le nombre de bits par nœuds et le temps d'exécution de l'algorithme de compression.
	
	Dans le cas du moteur $k^2$-GraCE, nous avons constaté que l'utilisation de la matrice d'adjacence pour la construction de l'arbre est trop couteuse en temps d'exécution. L'utilisation de la structure proposée dans la bibliothèque \gls{snap} donne des résultats nettement meilleurs pour cette métrique. Nous avons aussi observé que le choix du paramètre k influence fortement sur les performances de la compression. Selon les résultats obtenus, la valeur optimale dans le cas statique est bien k=2. De plus, nous avons constaté que l'utilisation d'un ré-ordonnancement des nœuds n'est intéressante que dans le cas des graphes autres que les graphes du web où nous avons obtenu une amélioration du ratio de compression d'un facteur de 1,4 dans le cas du graphe wiki-Vote. La généralisation  proposée pour le cas des graphes statiques non orientés permet de doubler le ratio de compression améliorant ainsi la qualité de la compression. D'autre part, nous avons remarqué que l'utilisation du graphe original dans le cas dynamique donne de meilleurs résultats. En effet, nous avons constaté que l'utilisation de la matrice de différence n'est bénéfique que dans le cas où les captures possèdent un degré élevé de ressemblance des liens, ce qui n'est généralement pas le cas dans les graphes réels.
	
	Le deuxième moteur, P-GraCE, permet de compresser le graphe en entrée avec ses sous-structures les plus importantes. Les tests ont montré qu'il n'est pas intéressant d'utiliser le troisième type de motifs dans les méthodes basées sur les propriétés de la matrice d'adjacence car il est peu fréquent dans les graphes réels. Pour le beam-search, nous avons bien remarqué que le niveau d'agrégation doit être choisi d'une manière qui assure un compromis entre le temps d'exécution et le ratio de compression. L'évaluation des différentes phases de  l'approche basée sur les méthodes de clustering a montré que les paramètres donnant les meilleurs performances consiste en :(1) l'utilisation de méthode \textit{Step} comme méthode de sélection, (2) l'utilisation des trois méthodes de clustering ensembles pour l'extraction de motifs. Finalement, l'évaluation de la méthode que nous proposons a montré qu'elle donne des résultats compétitifs en terme de temps de compression. Certes, le moteur k2-GraCE offre un meilleur ratio dans le cas dynamique mais il n'offre pas les mêmes avantages que la méthode que nous proposons. En effet, le résultat obtenu par DDSM permet une analyse très rapide des communautés et leur comportement temporel.
	
	La comparaison entre les deux moteurs nous a amené à déduire que l'utilisation du moteur $k^2$-GraCE est meilleur dans le cas où le but est de diminuer la taille du graphe uniquement. Cependant, le moteur P-GraCE permet d'avoir des informations interprétables qui aident dans l'analyse du graphe car il permet de synthétiser l'information incluse dans le graphe initiale sous forme des sous-structures les plus pertinentes.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	